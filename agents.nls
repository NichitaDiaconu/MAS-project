;Routing table indexes:
;0 blue
;1 red
;2 green
;3 black
;4 "Evertsenstraat" 5
;5 "Museumplein" 13
;6 "Hendrikkade" 9

; Graph indexes
;0 "Amstel"
;1 "Amstelveenseweg" 
;2 "Buikslotermeer" 
;3 "Centraal" 
;4 "Dam"
;5 "Evertsenstraat" 
;6 "Floradorp" 
;7 "Haarlemmermeerstation" 
;8 "Hasseltweg" 
;9 "Hendrikkade"
;10 "Leidseplein" 
;11 "Lelylaan" 
;12 "Muiderpoort" 
;13 "Museumplein" 
;14 "RAI" 
;15 "SciencePark" 
;16 "Sloterdijk"
;17 "Surinameplein" 
;18 "UvA" 
;19 "VU" 
;20 "Waterlooplein" 
;21 "Weesperplein" 
;22 "Wibautstraat" 
;23 "Zuid"

;bus colors: 0 blue 1 red 2 green 3 black 4 unassigned

; Implicit things nobody said:
; you add busses at a tick and they only appear at the next tick; moreover, id of the bus with add-bus is unknown...

; Messages are prepended [ ticks bus_id ]

; you don'tknow if bus 24 will be called last

; a new bus should have bus_color = 4 and current_stop = 3
buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".

  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).
    
  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  bus_routes 
  central_to_route_routes 
  bus_stops_to_idx 
  bus_color
  initiated_buses_types
  initiated_buses_colors
  routing_table
  capacity
  empty_capacity
  color_to_buses
  asked_for_help
  
]

globals [graph]

to-report get-routing-index-of-destination [ dest_id ]
  if dest_id = 5 [
    ; Evertsenstraat
    report 4
  ]
  if dest_id = 13 [
    ; Museumplein
    report 5
  ]
  if dest_id = 9 [
    ; Hendrikkade
    report 6
  ]
  foreach [3 4 5 10 13 22 21 20 9] [
    if ? = dest_id [
      report 0
    ]
  ]
  foreach [5 16 11 1 19 23 13 7 17] [
    if ? = dest_id [
      report 1
    ]
  ]
  foreach [22 13 23 14 0 15 18 15 12] [
    if ? = dest_id [
      report 2
    ]
  ]
  foreach [9 8 6 8 2 8] [
    if ? = dest_id [
      report 3
    ]
  ]
  report -1
end


; creating a bus takes:
;     - initiate-new-bus at tick i
;     - create-initiated-bus at tick i+1
to initiate-new-bus [ b_type b_color ] 
   ;show "initiating"
   if bus_id != 24 [
     show "ERROR we agreed on making buses only from bus 24"
   ]
   
   set initiated_buses_types lput b_type initiated_buses_types
   set initiated_buses_colors lput b_color initiated_buses_colors

   ;FOR NOT VOTING INITIAL BUSES
   if b_type = -1 [
     set b_type 3
   ]
   add-bus b_type
   
end

to init-buses 
  ; Initialize your agents here.
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  set bus_color 4
  set bus_routes [[3 4 5 10 13 22 21 20 9] [5 16 11 1 19 23 13 7 17] [22 13 23 14 0 15 18 15 12] [9 8 6 8 2 8]]
  set central_to_route_routes [[3 4] [3 4 5 16] [3 9 20 21 22 13] [3 9 8]]
  set bus_stops_to_idx ["Amstel" "Amstelveenseweg" "Buikslotermeer" "Centraal" "Dam"
    "Evertsenstraat" "Floradorp" "Haarlemmermeerstation" "Hasseltweg" "Hendrikkade"
    "Leidseplein" "Lelylaan" "Muiderpoort" "Museumplein" "RAI" "SciencePark" "Sloterdijk"
    "Surinameplein" "UvA" "VU" "Waterlooplein" "Weesperplein" "Wibautstraat" "Zuid"]
  set routing_table [["D" 5 13 9 "D" "D" "D"] [5 "D" 13 13 "D" "D" 13] [13 13 "D" 13 13 "D" 13] [9 9 9 "D" 9 9 "D"]]
  set initiated_buses_types []
  set initiated_buses_colors []
  set asked_for_help False
  send-message 24 (list "initiated" bus_type)
end

to message-bus-new-stats [ new_bus_type new_bus_color new_bus_id]
  ; HERE IS THE THING FOR INITIAL BUSES so they cannot call more buses
  let no_vote False
  if new_bus_type = -1 [
    set new_bus_type 3
    set no_vote True
  ]
  ; to here
  
  send-message new_bus_id (list "new_bus_instructions" new_bus_color no_vote)
end

to send-message-help
  ; Send message
  if asked_for_help = False and capacity > 0 and empty_capacity / capacity < 0.25[
    ; to bus 24, I am bus_id with color bus_color make a bus of type 3
    send-message 24 (list "help" bus_color 3);word bus_id (word " " (word bus_color (" 3")))
    set asked_for_help True
  ]
end

to process-messages 
  ; process messages
  ifelse bus_id = 24 [

    ; filter messages to proces
    let to_process filter [ item 0 ? = ticks - 1 ] inbox
    
    let new_initiate_msgs filter [ item 0 item 2 ? = "help" ] to_process
    let new_construct_msgs filter [ item 0 item 2 ? = "initiated" ] to_process
    
    ; filter images to leave in the inbox
    set inbox filter [ item 0 ? != ticks - 1 ] inbox
    
    ;send message to newly initiated bus about his color and type
    foreach new_construct_msgs [
      let new_bus_id item 1 ?
      let new_bus_type item 1 item 2 ?

      ;DUE TO THE FACT THAT I DO NOT SEARCH IN REQUESTS FOR BUS_COLOR BUS_TYPE PAIR, THIS ONLY WORKS IF BUS_TYPE IS ALWAYS THE SAME....
      let new_bus_color last initiated_buses_colors
      set initiated_buses_colors but-last initiated_buses_colors
      message-bus-new-stats new_bus_type new_bus_color new_bus_id
      
      ;update the color_to_buses for bus 24
      if member? new_bus_id item 4 color_to_buses [
        ;If the bus was part of the free buses ( NOT the newly initialized ) as he cannot be in the table if it's his first appearence
        
        ;replace the list of free buses with the list of free buses except for the newly set bus
        let replace_with1 remove new_bus_id item 4 color_to_buses
        set color_to_buses replace-item 4 color_to_buses replace_with1
      ]
      
      ;add the new bus to the list of buses with the specific color
      let replace_with lput new_bus_id item new_bus_color color_to_buses
      set color_to_buses replace-item new_bus_color color_to_buses replace_with
    ]
    
    ; spawn at most 1 bus per line at a tick no matter what they ask.... would result in two buses at same location
    let new_per_color [0 0 0 0]
    foreach new_initiate_msgs [
      let pair item 2 ?
      let new_message item 0 pair
      let new_color item 1 pair
      let new_type item 2 pair
      
      if item new_color new_per_color = 0[
        initiate-new-bus new_type new_color
        set new_per_color replace-item new_color new_per_color 1
      ]
    ]
  ][
   ; message should contain new_bus_instruction
   
   if length inbox > 1[
     show "ERROR regular buses inbox should never have more than 1 message inside"
   ]
   if length inbox = 1[
     let new_message item 0 inbox
     let pair item 2 new_message
     let message_title item 0 pair
     if message_title != "new_bus_instructions" [
       show "ERROR regular buses should only get new_bus_instructions"
     ]
     let new_bus_color item 1 pair
     let no_vote item 2 pair
     set capacity item bus_type [0 12 60 150]
     set empty_capacity item bus_type [0 12 60 150]
     if no_vote = True [
       set asked_for_help True
     ]
     set bus_color new_bus_color
     
     set inbox []
   ]
  ]
  ;endif
end

to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.
  ; The MAIN function called on LOOP at every tick
  
  ; Description ( too see how a new bus is creted there is documentation above initiate-new-bus method ):
  if ticks = 2 and bus_id = 24 [
    set bus_color 0
    set color_to_buses [[24][][][][]]
    set asked_for_help True
    set inbox []
  ]
  
  if bus_color != 4 [
  ;if bus has been created, not only initiated
  ;if bus_id = 24 [
    ;create-initiated-buses
  ;]
  ;pick up / drop off logic
  pick-drop
  
  ;when not between stations aka when in a station
  if current_stop != -1
  [
    determine-and-set-next-stop
  ]

  travel-to next_stop
   
  send-message-help
  ; initiate one big bus for each line initially 
  ; initiate these busses from bus 24 at tick 2
  if ticks = 2 and bus_id = 24 [
    ;pass
    initiate-new-bus 3 0
    initiate-new-bus 3 1
    initiate-new-bus 3 2
    initiate-new-bus 3 3
  ]
  ;if ticks > 1 and bus_id = 24 and ticks < 30 and ticks mod 14 = 0  [
  ;  ;pass
  ;  initiate-new-bus -1 0
  ;  initiate-new-bus -1 3
  ;]
  ;if ticks > 1 and bus_id = 24 and ticks < 41 and ticks mod 20 = 0  [
  ;  ;pass
  ;  initiate-new-bus -1 1
  ;  initiate-new-bus -1 2
  ;]
  
  ;if ticks > 1 and bus_id = 24 and ticks < 61 and ticks mod 10 = 0  [
  ;  ;pass
  ;  initiate-new-bus 3 0
  ;  initiate-new-bus 3 3
  ;  initiate-new-bus 3 1
  ;  initiate-new-bus 3 2
  ;]
  ]
  process-messages
end

to determine-and-set-next-stop
  ;create a method that sets next_stop of any bus to the next stop on that buss line

  let idx 0
  ifelse bus_color != 4
  ; bus only initialized but not created
  [
  foreach item bus_color bus_routes [
    ; for each station in the route of this buss color 
    let prev_idx idx - 1
    if prev_idx = -1[
      set prev_idx length item bus_color bus_routes
      set prev_idx prev_idx - 1
    ]
    if ? = current_stop and ( idx = 0 or previous_stop = item prev_idx item bus_color bus_routes )[
      ; if we found the current station, set the next station
      ifelse idx + 1 = length item bus_color bus_routes [
        ; if we are at the last stop in the list
        set next_stop item 0 item bus_color bus_routes
      ]
      [
        let next_idx idx + 1
        set next_stop item next_idx item bus_color bus_routes
        ;show word "at stop " (word current_stop (word " set next stop " (word next_stop)))
      ]
      ;endif
    ]
    set idx idx + 1
  ]
  if next_stop = -1 [
    ; if we did not find current_stop in the route of this buss line
    ; means we are not on our line yet and we should go there 1st by finding our route in central_to_route_routes
    set idx 0
    foreach item bus_color central_to_route_routes [
      ; for each station in the route from centrat to this colors route 
      if ? = current_stop [
        ; if we found the current station, set the next station
        ifelse idx + 1 = length item bus_color bus_routes [
          ; if we are at the last stop in the list
          show "ERROR we should be on this buss colour normal route"
        ]
        [
          let next_idx idx + 1
          let my_colors_route_to_route item bus_color central_to_route_routes
          set next_stop item next_idx my_colors_route_to_route
        ]
        ;endif
      ]
      set idx idx + 1
    ]
  ]
  ]
  [
    ;show "WARNING tried to set next stop of an uncreated bus"
  ]
end



;picking up and delivering logic
;pick up who
to pick-drop
  ;pick up / drop off logic
  
  ;Drop first
  if current_stop != -1 [
    ;if bus is at a station
    foreach bus_passengers [
      ;for each bus see who it should drop off
      ;bus-passangers returns a list of passengers that the agent is currently carrying
      ;(represented as a list of [passenger_id bus_stop] tuples)
      
      ; drop off everyone who has current station as intermediary or final station
      let passenger_dest get-routing-index-of-destination item 1 ?
      let routing_dest item passenger_dest item bus_color routing_table
      if routing_dest = "D" [
        set routing_dest item 1 ?
      ]
      if routing_dest = current_stop [
        drop-off-passenger item 0 ?
        set empty_capacity empty_capacity + 1
      ]
    ]
    
    ;Pickup then
    if empty_capacity > 0 [ 
    foreach get-passengers-at-stop current_stop [
      ;for each bus see who it should pick up
      ;pickup everyone except for those who need to be dropped at current station
      let passenger_dest get-routing-index-of-destination item 1 ?
      let routing_dest item passenger_dest item bus_color routing_table
      if routing_dest != current_stop and empty_capacity > 0[
        pick-up-passenger item 0 ?
        set empty_capacity empty_capacity - 1
      ]
    ]
    ]
  ]
end